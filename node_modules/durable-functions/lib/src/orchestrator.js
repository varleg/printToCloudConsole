"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug = require("debug");
const aggregatederror_1 = require("./aggregatederror");
const classes_1 = require("./classes");
const durableerror_1 = require("./durableerror");
const orchestrationfailureerror_1 = require("./orchestrationfailureerror");
const log = debug("orchestrator");
class Orchestrator {
    constructor(fn) {
        this.fn = fn;
    }
    listen() {
        return this.handle.bind(this);
    }
    handle(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const orchestrationBinding = classes_1.Utils.getInstancesOf(context.bindings, new classes_1.DurableOrchestrationBindingInfo())[0];
            if (!orchestrationBinding) {
                throw new Error("Could not finding an orchestrationClient binding on context.");
            }
            const state = orchestrationBinding.history;
            const input = orchestrationBinding.input;
            const instanceId = orchestrationBinding.instanceId;
            let decisionStartedEvent = classes_1.Utils.ensureNonNull(state.find((e) => e.EventType === classes_1.HistoryEventType.OrchestratorStarted), "The orchestrator can not execute without an OrchestratorStarted event.");
            this.currentUtcDateTime = new Date(decisionStartedEvent.Timestamp);
            this.newGuidCounter = 0;
            this.subOrchestratorCounter = 0;
            context.df = {
                instanceId,
                isReplaying: orchestrationBinding.isReplaying,
                parentInstanceId: orchestrationBinding.parentInstanceId,
                callActivity: this.callActivity.bind(this, state),
                callActivityWithRetry: this.callActivityWithRetry.bind(this, state),
                callEntity: this.callEntity.bind(this, state),
                callSubOrchestrator: this.callSubOrchestrator.bind(this, state),
                callSubOrchestratorWithRetry: this.callSubOrchestratorWithRetry.bind(this, state),
                callHttp: this.callHttp.bind(this, state),
                continueAsNew: this.continueAsNew.bind(this, state),
                createTimer: this.createTimer.bind(this, state),
                getInput: this.getInput.bind(this, input),
                newGuid: this.newGuid.bind(this, instanceId),
                setCustomStatus: this.setCustomStatus.bind(this),
                waitForExternalEvent: this.waitForExternalEvent.bind(this, state),
                Task: {
                    all: this.all.bind(this, state),
                    any: this.any.bind(this, state),
                },
                currentUtcDateTime: this.currentUtcDateTime,
            };
            const gen = this.fn(context);
            const actions = [];
            let partialResult;
            try {
                let g = gen.next(undefined);
                while (true) {
                    if (!classes_1.TaskFilter.isYieldable(g.value)) {
                        if (!g.done) {
                            g = gen.next(g.value);
                            continue;
                        }
                        else {
                            log("Iterator is done");
                            context.done(undefined, new classes_1.OrchestratorState({
                                isDone: true,
                                output: g.value,
                                actions,
                                customStatus: this.customStatus,
                            }));
                            return;
                        }
                    }
                    partialResult = g.value;
                    const newActions = partialResult.yieldNewActions();
                    if (newActions && newActions.length > 0) {
                        actions.push(newActions);
                    }
                    if (classes_1.TaskFilter.isSingleTask(partialResult) &&
                        partialResult.action instanceof classes_1.ContinueAsNewAction) {
                        context.done(undefined, new classes_1.OrchestratorState({
                            isDone: true,
                            output: undefined,
                            actions,
                            customStatus: this.customStatus,
                        }));
                        return;
                    }
                    if (!classes_1.TaskFilter.isCompletedTask(partialResult)) {
                        context.done(undefined, new classes_1.OrchestratorState({
                            isDone: false,
                            output: undefined,
                            actions,
                            customStatus: this.customStatus,
                        }));
                        return;
                    }
                    if (state[partialResult.completionIndex] !== undefined) {
                        context.df.isReplaying = state[partialResult.completionIndex].IsPlayed;
                    }
                    if (classes_1.TaskFilter.isFailedTask(partialResult)) {
                        if (!gen.throw) {
                            throw new Error("Cannot properly throw the execption returned by customer code");
                        }
                        g = gen.throw(partialResult.exception);
                        continue;
                    }
                    if (g.done) {
                        log("Iterator is done");
                        context.done(undefined, new classes_1.OrchestratorState({
                            isDone: true,
                            actions,
                            output: partialResult.result,
                            customStatus: this.customStatus,
                        }));
                        return;
                    }
                    const newDecisionStartedEvent = state.find((e) => e.EventType === classes_1.HistoryEventType.OrchestratorStarted &&
                        e.Timestamp > decisionStartedEvent.Timestamp);
                    decisionStartedEvent = newDecisionStartedEvent || decisionStartedEvent;
                    context.df.currentUtcDateTime = this.currentUtcDateTime = new Date(decisionStartedEvent.Timestamp);
                    if (state[partialResult.completionIndex] !== undefined) {
                        context.df.isReplaying = state[partialResult.completionIndex].IsPlayed;
                    }
                    g = gen.next(partialResult.result);
                }
            }
            catch (error) {
                const errorState = new classes_1.OrchestratorState({
                    isDone: false,
                    output: undefined,
                    actions,
                    error: error.message,
                    customStatus: this.customStatus,
                });
                context.done(new orchestrationfailureerror_1.OrchestrationFailureError(error, errorState), undefined);
                return;
            }
        });
    }
    callActivity(state, name, input) {
        const newAction = new classes_1.CallActivityAction(name, input);
        const taskScheduled = this.findTaskScheduled(state, name);
        const taskCompleted = this.findTaskCompleted(state, taskScheduled);
        const taskFailed = this.findTaskFailed(state, taskScheduled);
        this.setProcessed([taskScheduled, taskCompleted, taskFailed]);
        if (taskCompleted) {
            const result = this.parseHistoryEvent(taskCompleted);
            return classes_1.TaskFactory.SuccessfulTask(newAction, result, taskCompleted.Timestamp, taskCompleted.TaskScheduledId, state.indexOf(taskCompleted));
        }
        else if (taskFailed) {
            return classes_1.TaskFactory.FailedTask(newAction, taskFailed.Reason, taskFailed.Timestamp, taskFailed.TaskScheduledId, state.indexOf(taskFailed), new durableerror_1.DurableError(taskFailed.Reason));
        }
        else {
            return classes_1.TaskFactory.UncompletedTask(newAction);
        }
    }
    callActivityWithRetry(state, name, retryOptions, input) {
        const newAction = new classes_1.CallActivityWithRetryAction(name, retryOptions, input);
        let attempt = 1;
        let taskScheduled;
        let taskFailed;
        let taskRetryTimer;
        for (let i = 0; i < state.length; i++) {
            const historyEvent = state[i];
            if (historyEvent.IsProcessed) {
                continue;
            }
            if (!taskScheduled) {
                if (historyEvent.EventType === classes_1.HistoryEventType.TaskScheduled) {
                    if (historyEvent.Name === name) {
                        taskScheduled = historyEvent;
                    }
                }
                continue;
            }
            if (historyEvent.EventType === classes_1.HistoryEventType.TaskCompleted) {
                if (historyEvent.TaskScheduledId === taskScheduled.EventId) {
                    const taskCompleted = historyEvent;
                    this.setProcessed([taskScheduled, taskCompleted]);
                    const result = this.parseHistoryEvent(taskCompleted);
                    return classes_1.TaskFactory.SuccessfulTask(newAction, result, taskCompleted.Timestamp, taskCompleted.TaskScheduledId, i);
                }
                else {
                    continue;
                }
            }
            if (!taskFailed) {
                if (historyEvent.EventType === classes_1.HistoryEventType.TaskFailed) {
                    if (historyEvent.TaskScheduledId === taskScheduled.EventId) {
                        taskFailed = historyEvent;
                    }
                }
                continue;
            }
            if (!taskRetryTimer) {
                if (historyEvent.EventType === classes_1.HistoryEventType.TimerCreated) {
                    taskRetryTimer = historyEvent;
                }
                else {
                    continue;
                }
            }
            if (historyEvent.EventType === classes_1.HistoryEventType.TimerFired) {
                if (historyEvent.TimerId === taskRetryTimer.EventId) {
                    const taskRetryTimerFired = historyEvent;
                    this.setProcessed([
                        taskScheduled,
                        taskFailed,
                        taskRetryTimer,
                        taskRetryTimerFired,
                    ]);
                    if (attempt >= retryOptions.maxNumberOfAttempts) {
                        return classes_1.TaskFactory.FailedTask(newAction, taskFailed.Reason, taskFailed.Timestamp, taskFailed.TaskScheduledId, i, new durableerror_1.DurableError(taskFailed.Reason));
                    }
                    else {
                        attempt++;
                        taskScheduled = undefined;
                        taskFailed = undefined;
                        taskRetryTimer = undefined;
                    }
                }
                else {
                    continue;
                }
            }
        }
        return classes_1.TaskFactory.UncompletedTask(newAction);
    }
    callEntity(state, entityId, operationName, operationInput) {
        const newAction = new classes_1.CallEntityAction(entityId, operationName, operationInput);
        const schedulerId = classes_1.EntityId.getSchedulerIdFromEntityId(entityId);
        const eventSent = this.findEventSent(state, schedulerId, "op");
        let eventRaised;
        if (eventSent) {
            const eventSentInput = eventSent && eventSent.Input
                ? JSON.parse(eventSent.Input)
                : undefined;
            eventRaised = eventSentInput
                ? this.findEventRaised(state, eventSentInput.id)
                : undefined;
        }
        this.setProcessed([eventSent, eventRaised]);
        if (eventRaised) {
            const parsedResult = this.parseHistoryEvent(eventRaised);
            return classes_1.TaskFactory.SuccessfulTask(newAction, JSON.parse(parsedResult.result), eventRaised.Timestamp, eventSent.EventId, state.indexOf(eventRaised));
        }
        return classes_1.TaskFactory.UncompletedTask(newAction);
    }
    callSubOrchestrator(state, name, input, instanceId) {
        if (!name) {
            throw new Error("A sub-orchestration function name must be provided when attempting to create a suborchestration");
        }
        const newAction = new classes_1.CallSubOrchestratorAction(name, instanceId, input);
        const subOrchestratorCreated = this.findSubOrchestrationInstanceCreated(state, name, instanceId);
        const subOrchestratorCompleted = this.findSubOrchestrationInstanceCompleted(state, subOrchestratorCreated);
        const subOrchestratorFailed = this.findSubOrchestrationInstanceFailed(state, subOrchestratorCreated);
        this.setProcessed([
            subOrchestratorCreated,
            subOrchestratorCompleted,
            subOrchestratorFailed,
        ]);
        if (subOrchestratorCompleted) {
            const result = this.parseHistoryEvent(subOrchestratorCompleted);
            return classes_1.TaskFactory.SuccessfulTask(newAction, result, subOrchestratorCompleted.Timestamp, subOrchestratorCompleted.TaskScheduledId, state.indexOf(subOrchestratorCompleted));
        }
        else if (subOrchestratorFailed) {
            return classes_1.TaskFactory.FailedTask(newAction, subOrchestratorFailed.Reason, subOrchestratorFailed.Timestamp, subOrchestratorFailed.TaskScheduledId, state.indexOf(subOrchestratorFailed), new durableerror_1.DurableError(subOrchestratorFailed.Reason));
        }
        else {
            return classes_1.TaskFactory.UncompletedTask(newAction);
        }
    }
    callSubOrchestratorWithRetry(state, name, retryOptions, input, instanceId) {
        if (!name) {
            throw new Error("A sub-orchestration function name must be provided when attempting to create a suborchestration");
        }
        const newAction = new classes_1.CallSubOrchestratorWithRetryAction(name, retryOptions, input, instanceId);
        let attempt = 1;
        let subOrchestratorCreated;
        let subOrchestratorFailed;
        let taskRetryTimer;
        for (let i = 0; i < state.length; i++) {
            const historyEvent = state[i];
            if (historyEvent.IsProcessed) {
                continue;
            }
            if (!subOrchestratorCreated) {
                if (historyEvent.EventType === classes_1.HistoryEventType.SubOrchestrationInstanceCreated) {
                    const subOrchEvent = historyEvent;
                    if (subOrchEvent.Name === name &&
                        (!instanceId || instanceId === subOrchEvent.InstanceId)) {
                        subOrchestratorCreated = subOrchEvent;
                    }
                }
                continue;
            }
            if (historyEvent.EventType === classes_1.HistoryEventType.SubOrchestrationInstanceCompleted) {
                if (historyEvent.TaskScheduledId ===
                    subOrchestratorCreated.EventId) {
                    const subOrchCompleted = historyEvent;
                    this.setProcessed([subOrchestratorCreated, subOrchCompleted]);
                    const result = this.parseHistoryEvent(subOrchCompleted);
                    return classes_1.TaskFactory.SuccessfulTask(newAction, result, subOrchCompleted.Timestamp, subOrchCompleted.TaskScheduledId, i);
                }
                else {
                    continue;
                }
            }
            if (!subOrchestratorFailed) {
                if (historyEvent.EventType === classes_1.HistoryEventType.SubOrchestrationInstanceFailed) {
                    if (historyEvent.TaskScheduledId ===
                        subOrchestratorCreated.EventId) {
                        subOrchestratorFailed = historyEvent;
                    }
                }
                continue;
            }
            if (!taskRetryTimer) {
                if (historyEvent.EventType === classes_1.HistoryEventType.TimerCreated) {
                    taskRetryTimer = historyEvent;
                }
                continue;
            }
            if (historyEvent.EventType === classes_1.HistoryEventType.TimerFired) {
                if (historyEvent.TimerId === taskRetryTimer.EventId) {
                    const taskRetryTimerFired = historyEvent;
                    this.setProcessed([
                        subOrchestratorCreated,
                        subOrchestratorFailed,
                        taskRetryTimer,
                        taskRetryTimerFired,
                    ]);
                    if (attempt >= retryOptions.maxNumberOfAttempts) {
                        return classes_1.TaskFactory.FailedTask(newAction, subOrchestratorFailed.Reason, subOrchestratorFailed.Timestamp, subOrchestratorFailed.TaskScheduledId, i, new durableerror_1.DurableError(subOrchestratorFailed.Reason));
                    }
                    else {
                        attempt += 1;
                        subOrchestratorCreated = undefined;
                        subOrchestratorFailed = undefined;
                        taskRetryTimer = undefined;
                    }
                }
                else {
                    continue;
                }
            }
        }
        return classes_1.TaskFactory.UncompletedTask(newAction);
    }
    callHttp(state, method, uri, content, headers, tokenSource) {
        if (content && typeof content !== "string") {
            content = JSON.stringify(content);
        }
        const req = new classes_1.DurableHttpRequest(method, uri, content, headers, tokenSource);
        const newAction = new classes_1.CallHttpAction(req);
        const httpScheduled = this.findTaskScheduled(state, "BuiltIn::HttpActivity");
        const httpCompleted = this.findTaskCompleted(state, httpScheduled);
        const httpFailed = this.findTaskFailed(state, httpScheduled);
        this.setProcessed([httpScheduled, httpCompleted, httpFailed]);
        if (httpCompleted) {
            const result = this.parseHistoryEvent(httpCompleted);
            return classes_1.TaskFactory.SuccessfulTask(newAction, result, httpCompleted.Timestamp, httpCompleted.TaskScheduledId, state.indexOf(httpCompleted));
        }
        else if (httpFailed) {
            return classes_1.TaskFactory.FailedTask(newAction, httpFailed.Reason, httpFailed.Timestamp, httpFailed.TaskScheduledId, state.indexOf(httpFailed), new durableerror_1.DurableError(httpFailed.Reason));
        }
        else {
            return classes_1.TaskFactory.UncompletedTask(newAction);
        }
    }
    continueAsNew(state, input) {
        const newAction = new classes_1.ContinueAsNewAction(input);
        return classes_1.TaskFactory.UncompletedTask(newAction);
    }
    createTimer(state, fireAt) {
        const newAction = new classes_1.CreateTimerAction(fireAt);
        const timerCreated = this.findTimerCreated(state, fireAt);
        const timerFired = this.findTimerFired(state, timerCreated);
        this.setProcessed([timerCreated, timerFired]);
        if (timerFired) {
            return classes_1.TaskFactory.CompletedTimerTask(newAction, timerFired.Timestamp, timerFired.TimerId, state.indexOf(timerFired));
        }
        else {
            return classes_1.TaskFactory.UncompletedTimerTask(newAction);
        }
    }
    getInput(input) {
        return input;
    }
    isLocked(contextLocks) {
        return new classes_1.LockState(contextLocks && contextLocks !== null, contextLocks);
    }
    lock(state, instanceId, contextLocks, entities) {
        if (contextLocks) {
            throw new Error("Cannot acquire more locks when already holding some locks.");
        }
        if (!entities || entities.length === 0) {
            throw new Error("The list of entities to lock must not be null or empty.");
        }
        entities = this.cleanEntities(entities);
        this.newGuid(instanceId);
        return undefined;
    }
    cleanEntities(entities) {
        return entities.sort((a, b) => {
            if (a.key === b.key) {
                if (a.name === b.name) {
                    return 0;
                }
                else if (a.name < b.name) {
                    return -1;
                }
                else {
                    return 1;
                }
            }
            else if (a.key < b.key) {
                return -1;
            }
            else {
                return 1;
            }
        });
    }
    newGuid(instanceId) {
        const guidNameValue = `${instanceId}_${this.currentUtcDateTime.valueOf()}_${this.newGuidCounter}`;
        this.newGuidCounter++;
        return classes_1.GuidManager.createDeterministicGuid(classes_1.GuidManager.UrlNamespaceValue, guidNameValue);
    }
    setCustomStatus(customStatusObject) {
        this.customStatus = customStatusObject;
    }
    waitForExternalEvent(state, name) {
        const newAction = new classes_1.WaitForExternalEventAction(name, classes_1.ExternalEventType.ExternalEvent);
        const eventRaised = this.findEventRaised(state, name);
        this.setProcessed([eventRaised]);
        if (eventRaised) {
            const result = this.parseHistoryEvent(eventRaised);
            return classes_1.TaskFactory.SuccessfulTask(newAction, result, eventRaised.Timestamp, eventRaised.EventId, state.indexOf(eventRaised));
        }
        else {
            return classes_1.TaskFactory.UncompletedTask(newAction);
        }
    }
    all(state, tasks) {
        let maxCompletionIndex;
        const errors = [];
        const results = [];
        for (const task of tasks) {
            if (!classes_1.TaskFilter.isCompletedTask(task)) {
                return classes_1.TaskFactory.UncompletedTaskSet(tasks);
            }
            if (!maxCompletionIndex) {
                maxCompletionIndex = task.completionIndex;
            }
            else if (maxCompletionIndex < task.completionIndex) {
                maxCompletionIndex = task.completionIndex;
            }
            if (classes_1.TaskFilter.isFailedTask(task)) {
                errors.push(task.exception);
            }
            else {
                results.push(task.result);
            }
        }
        const completionIndex = maxCompletionIndex;
        if (errors.length > 0) {
            return classes_1.TaskFactory.FailedTaskSet(tasks, completionIndex, new aggregatederror_1.AggregatedError(errors));
        }
        else {
            return classes_1.TaskFactory.SuccessfulTaskSet(tasks, completionIndex, results);
        }
    }
    any(state, tasks) {
        if (!tasks || tasks.length === 0) {
            throw new Error("At least one yieldable task must be provided to wait for.");
        }
        let firstCompleted;
        for (const task of tasks) {
            if (classes_1.TaskFilter.isCompletedTask(task)) {
                if (!firstCompleted) {
                    firstCompleted = task;
                }
                else if (task.completionIndex < firstCompleted.completionIndex) {
                    firstCompleted = task;
                }
            }
        }
        if (firstCompleted) {
            return classes_1.TaskFactory.SuccessfulTaskSet(tasks, firstCompleted.completionIndex, firstCompleted);
        }
        else {
            return classes_1.TaskFactory.UncompletedTaskSet(tasks);
        }
    }
    parseHistoryEvent(directiveResult) {
        let parsedDirectiveResult;
        switch (directiveResult.EventType) {
            case classes_1.HistoryEventType.EventRaised:
                const eventRaised = directiveResult;
                parsedDirectiveResult =
                    eventRaised && eventRaised.Input ? JSON.parse(eventRaised.Input) : undefined;
                break;
            case classes_1.HistoryEventType.SubOrchestrationInstanceCompleted:
                parsedDirectiveResult = JSON.parse(directiveResult.Result);
                break;
            case classes_1.HistoryEventType.TaskCompleted:
                parsedDirectiveResult = JSON.parse(directiveResult.Result);
                break;
            default:
                break;
        }
        return parsedDirectiveResult;
    }
    findEventRaised(state, eventName) {
        const returnValue = eventName
            ? state.filter((val) => {
                return (val.EventType === classes_1.HistoryEventType.EventRaised &&
                    val.Name === eventName &&
                    !val.IsProcessed);
            })[0]
            : undefined;
        return returnValue;
    }
    findEventSent(state, instanceId, eventName) {
        const returnValue = eventName
            ? state.filter((val) => {
                return (val.EventType === classes_1.HistoryEventType.EventSent &&
                    val.InstanceId === instanceId &&
                    val.Name === eventName &&
                    !val.IsProcessed);
            })[0]
            : undefined;
        return returnValue;
    }
    findSubOrchestrationInstanceCreated(state, name, instanceId) {
        const matches = state.filter((val) => {
            return (val.EventType === classes_1.HistoryEventType.SubOrchestrationInstanceCreated &&
                !val.IsProcessed);
        });
        if (matches.length === 0) {
            return undefined;
        }
        this.subOrchestratorCounter++;
        const returnValue = matches[0];
        if (returnValue.Name !== name) {
            throw new Error(`The sub-orchestration call (n = ${this.subOrchestratorCounter}) should be executed with a function name of ${returnValue.Name} instead of the provided function name of ${name}. Check your code for non-deterministic behavior.`);
        }
        if (instanceId && returnValue.InstanceId !== instanceId) {
            throw new Error(`The sub-orchestration call (n = ${this.subOrchestratorCounter}) should be executed with an instance id of ${returnValue.InstanceId} instead of the provided instance id of ${instanceId}. Check your code for non-deterministic behavior.`);
        }
        return returnValue;
    }
    findSubOrchestrationInstanceCompleted(state, createdSubOrch) {
        if (createdSubOrch === undefined) {
            return undefined;
        }
        const matches = state.filter((val) => {
            return (val.EventType === classes_1.HistoryEventType.SubOrchestrationInstanceCompleted &&
                val.TaskScheduledId ===
                    createdSubOrch.EventId &&
                !val.IsProcessed);
        });
        return matches.length > 0
            ? matches[0]
            : undefined;
    }
    findSubOrchestrationInstanceFailed(state, createdSubOrchInstance) {
        if (createdSubOrchInstance === undefined) {
            return undefined;
        }
        const matches = state.filter((val) => {
            return (val.EventType === classes_1.HistoryEventType.SubOrchestrationInstanceFailed &&
                val.TaskScheduledId ===
                    createdSubOrchInstance.EventId &&
                !val.IsProcessed);
        });
        return matches.length > 0 ? matches[0] : undefined;
    }
    findTaskScheduled(state, name) {
        const returnValue = name
            ? state.filter((val) => {
                return (val.EventType === classes_1.HistoryEventType.TaskScheduled &&
                    val.Name === name &&
                    !val.IsProcessed);
            })[0]
            : undefined;
        return returnValue;
    }
    findTaskCompleted(state, scheduledTask) {
        if (scheduledTask === undefined) {
            return undefined;
        }
        const returnValue = scheduledTask
            ? state.filter((val) => {
                return (val.EventType === classes_1.HistoryEventType.TaskCompleted &&
                    val.TaskScheduledId === scheduledTask.EventId);
            })[0]
            : undefined;
        return returnValue;
    }
    findTaskFailed(state, scheduledTask) {
        if (scheduledTask === undefined) {
            return undefined;
        }
        const returnValue = scheduledTask
            ? state.filter((val) => {
                return (val.EventType === classes_1.HistoryEventType.TaskFailed &&
                    val.TaskScheduledId === scheduledTask.EventId);
            })[0]
            : undefined;
        return returnValue;
    }
    findTimerCreated(state, fireAt) {
        const returnValue = fireAt
            ? state.filter((val) => {
                return (val.EventType === classes_1.HistoryEventType.TimerCreated &&
                    new Date(val.FireAt).getTime() === fireAt.getTime());
            })[0]
            : undefined;
        return returnValue;
    }
    findTimerFired(state, createdTimer) {
        const returnValue = createdTimer
            ? state.filter((val) => {
                return (val.EventType === classes_1.HistoryEventType.TimerFired &&
                    val.TimerId === createdTimer.EventId);
            })[0]
            : undefined;
        return returnValue;
    }
    setProcessed(events) {
        events.map((val) => {
            if (val) {
                val.IsProcessed = true;
            }
        });
    }
}
exports.Orchestrator = Orchestrator;
//# sourceMappingURL=orchestrator.js.map